# [52. N皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)

*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。

![img](assets/8-queens.png)

上图为 8 皇后问题的一种解法。

给定一个整数 *n*，返回 *n* 皇后不同的解决方案的数量。

**示例:**

```
输入: 4
输出: 2
解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
```

 

**提示：**

- **皇后**，是[国际象棋](https://baike.baidu.com/item/国际象棋)中的棋子，意味着[国王](https://baike.baidu.com/item/国王)的妻子。皇后只做一件事，那就是“[吃子](https://baike.baidu.com/item/吃子)”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 [百度百科 - 皇后](https://baike.baidu.com/item/皇后/15860305?fr=aladdin) ）

```c++
class Solution {
private:
    std::vector<std::vector<int>> chessboard;
    int choices;
    int scale;

    void fill(int row, int col) {
        int l = col - 1, r = col + 1;
        for (int i = row + 1; i < scale; ++i) {
            if (l >= 0)chessboard[i][l] = 1;
            if (r < scale)chessboard[i][r] = 1;
            chessboard[i][col] = 1;
            l--, r++;
        }
    }

    void dfs(int row) {
        auto last_chessboard = chessboard;
        for (int i = 0; i < scale; ++i) {
            if (chessboard[row][i] == 0) {
                if (row == scale - 1) {
                    choices++;
                    continue;
                } else {
                    fill(row,i);
                    dfs(row + 1);
                    chessboard = last_chessboard;
                }
            }
        }
    }

public:
    int totalNQueens(int n) {
        scale = n;
        chessboard = std::vector<std::vector<int>>(n, std::vector<int>(n, 0));
        choices = 0;
        dfs(0);
        return choices;
    }
};
```

> 执行用时：64 ms, 在所有 C++ 提交中击败了7.35% 的用户
>
> 内存消耗：16.6 MB, 在所有 C++ 提交中击败了5.02% 的用户

题解用了位运算。

```c++
class Solution {
public:
    int totalNQueens(int n) {
        return solve(n, 0, 0, 0, 0);
    }

    int solve(int n, int row, int columns, int diagonals1, int diagonals2) {
        if (row == n) {
            return 1;
        } else {
            int count = 0;
            int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));
            while (availablePositions != 0) {
                int position = availablePositions & (-availablePositions);
                availablePositions = availablePositions & (availablePositions - 1);
                count += solve(n, row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1);
            }
            return count;
        }
    }
};
```
