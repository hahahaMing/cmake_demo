# [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N` 共有 `N` 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 `F` ，满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次*移动*，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 `X` 扔下（满足 `1 <= X <= N`）。

你的目标是**确切地**知道 `F` 的值是多少。

无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

**示例 1：**

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

**示例 2：**

```
输入：K = 2, N = 6
输出：3
```

**示例 3：**

```
输入：K = 3, N = 14
输出：4
```

 

**提示：**

1. `1 <= K <= 100`
2. `1 <= N <= 10000`

思路：

观察发现当答案为x时，k情况下能够确定所有状态（会不会碎）的最多的楼层N为：
$$
N_k(x)=\begin{cases}
x+\sum_1^{x-1}{N_{k-1}(i)}&k>1\\
x&k=1
\end{cases}
$$
解释一下：这里x表示可以尝试x次，这x次可以确定x个楼层的状态，然后这x分割楼层为几段：

第1段长$N_{k-1}(x-1)$，表示第1次从$N_{k-1}(x-1)+1$层扔，碎了，然后此层以下的楼层可以确定所有状态；

第2段长$N_{k-1}(x-2)$，表示第2次从$N_{k-1}(x-1)+1+N_{k-1}(x-2)+1$层扔，碎了（上一次没碎），然后此层以下的楼层可以确定所有状态。。。。。。。。直到最后一次碎了。



上面这个太有迷惑性了。。我自己第二次看都看不懂压，还是看下面的吧。



有递推关系:
$$
N_k(x)=N_k(x-1)+1+N_{k-1}(x-1)
$$
其中：

后两项表示第一次投掷的层数，如果碎了，则剩余层数为$N_{k-1}(x-1)$，都可以推出答案；如果没碎，则还有x-1次机会，从此层向上$N_k(x-1)$层可以被确定。

利用这些只要找到：
$$
N_K(x)\leqslant n \leqslant N_K(x-1)
$$
x即为结果。

下面需要减少迭代次数，蛋足够的情况，x最小值为$log_2(n)$。

```c++
class Solution {
private:
    int max_N(int k, int x) {
        if (k == 1) return x;
        int temp = x;
        for (int i = 1; i < x; i++) temp += max_N(k - 1, i);
        return temp;
    }

public:
    int superEggDrop(int K, int N) {
        int x = log(double(N)) / log(2);
        while (N > max_N(K, x)) x++;
        return x;
    }
    }
};
```

> 双百，我太牛逼了。
