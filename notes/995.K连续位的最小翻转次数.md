# [995. K 连续位的最小翻转次数](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/)

在仅包含 `0` 和 `1` 的数组 `A` 中，一次 *`K` 位翻转*包括选择一个长度为 `K` 的（连续）子数组，同时将子数组中的每个 `0` 更改为 `1`，而每个 `1` 更改为 `0`。

返回所需的 `K` 位翻转的最小次数，以便数组没有值为 `0` 的元素。如果不可能，返回 `-1`。

 

**示例 1：**

```
输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```

**示例 2：**

```
输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
```

**示例 3：**

```
输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
```

 

**提示：**

1. `1 <= A.length <= 30000`
2. `1 <= K <= A.length`

```c++
class Solution {
public:
    int minKBitFlips(std::vector<int> &A, int K) {
        //窗口向后滑，看到0开头就翻转，直到翻转不了
        int l = 0, n = A.size();
        int rst = 0;
        std::queue<int> que;
        bool change = false;
        int tmp = 0;//记录当前状态已经进行了多少步，
        while (l < n) {
            if (change) {//改变状态
                if (A[l] == 1) {//看到1变为0
                    rst++;
                    change = false;//更改状态为不变状态
                    que.push(tmp);
                    tmp = 0;
                } else {
                    A[l] = 1;
                }
            } else {//不变状态
                if (A[l] == 0) {//看到0
                    rst++;
                    change = true;
                    A[l] = 1;
                    if (que.empty())que.push(K);//初始化que
                    else {//更新que
                        que.push(tmp);
                        tmp = 0;
                    }
                }
            }
            //走了一步
            if (!que.empty()) {
                que.front()--;
                tmp++;
                if (tmp == K)tmp = 0;
            }
            l++;
            //当前状态结束，改变状态
            if (!que.empty() && que.front() == 0) {
                que.pop();
                change = !change;
            }
        }
        if (que.empty()) return rst;
        return -1;
    }
};
```

> 执行用时：112 ms, 在所有 C++ 提交中击败了67.35% 的用户
>
> 内存消耗：72.7 MB, 在所有 C++ 提交中击败了33.67% 的用户

挺累的，先不看题解了






