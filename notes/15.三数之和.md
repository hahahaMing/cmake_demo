# [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

**示例：**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

暴力，超时了。。。

```python
class Solution:
    def threeSum(self, nums: [int]) -> [[int]]:
        l = len(nums)
        if l < 3: return []
        rst = []
        nums.sort()

        for i in range(0,l-1):
            for j in range(i+1,l):
                temp = -nums[i]-nums[j]
                if temp in nums[j+1:l]:
                    tt = [nums[i],nums[j],temp]
                    if tt not in rst:
                        rst.append([nums[i],nums[j],temp])
        return rst
```

看了眼答案，没啥牛逼解法，和自己想法都差不多，同时表现为代码能力有待提高

细看他这个双指针思路比我清晰多了

copy一个

```python
class Solution:
    def threeSum(self, nums: [int]) -> [[int]]:
        n = len(nums)
        res = []
        if n < 3: return []
        nums.sort()
        res = []
        for i in range(n):
            if (nums[i] > 0):
                return res
            if (i > 0 and nums[i] == nums[i - 1]):
                continue
            L = i + 1
            R = n - 1
            while (L < R):
                if (nums[i] + nums[L] + nums[R] == 0):
                    res.append([nums[i], nums[L], nums[R]])
                    while (L < R and nums[L] == nums[L + 1]):
                        L = L + 1
                    while (L < R and nums[R] == nums[R - 1]):
                        R = R - 1
                    L = L + 1
                    R = R - 1
                elif (nums[i] + nums[L] + nums[R] > 0):
                    R = R - 1
                else:
                    L = L + 1
        return res
```

> 执行用时 :1164 ms, 在所有 Python3 提交中击败了43.62% 的用户
>
> 内存消耗 :16.1 MB, 在所有 Python3 提交中击败了73.01%的用户

```c++
class Solution {
public:
    std::vector<std::vector<int>> threeSum(std::vector<int>& nums) {
        int len = nums.size();
        std::vector<std::vector<int>> rst;
        if (len<3)return {};
        sort(nums.begin(),nums.end());
        for (int i = 0; i < len; ++i) {
            if (nums[i]>0)return rst;
            if (i>0&&nums[i]==nums[i-1])continue;
            int L = i+1,R = len-1;
            while (L<R){
                int tmp = nums[i] + nums[L] + nums[R];
                if (tmp== 0){
                    rst.push_back({nums[i], nums[L], nums[R]});
                    while (L<R&&nums[L]==nums[L+1])L++;
                    while (L<R&&nums[R]==nums[R-1])R--;
                    L++;R--;
                }else if(tmp>0){
                    R--;
                }else{
                    L++;
                }
            }
        }
        return rst;
    }
};
```

> 执行用时 :80 ms, 在所有 C++ 提交中击败了81.40% 的用户
>
> 内存消耗 :19.9 MB, 在所有 C++ 提交中击败了7.60%的用户


