# [60. 第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)

给出集合 `[1,2,3,…,*n*]`，其所有元素共有 *n*! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 *n* = 3 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 *n* 和 *k*，返回第 *k* 个排列。

**说明：**

- 给定 *n* 的范围是 [1, 9]。
- 给定 *k* 的范围是[1,  *n*!]。

**示例 1:**

```
输入: n = 3, k = 3
输出: "213"
```

**示例 2:**

```
输入: n = 4, k = 9
输出: "2314"
```

```c++
class Solution {
public:
    std::string getPermutation(int n, int k) {
        /*
         * 先把n个的排列弄出来
         *
         * 查看k的前缀
         */
        std::string str, rst;
        for (int i = 0; i < n; ++i) {
            str.push_back('0' + i + 1);
        }

        int c = n - 1, m = 1, turn;
        std::vector<int> factorials = {1};
        for (int i = 1; i < n; ++i) {
            m *= i;
            factorials.push_back(m);
        }
        //开始除
        while (!str.empty()) {
            turn = k/ factorials[c];
            k = k % factorials[c];
            if (k!=0){
                rst.push_back(str[turn]);
                str.erase(str.begin() + turn);
            }else{
                rst.push_back(str[turn-1]);
                str.erase(str.begin() + turn-1);
                std::reverse(str.begin(),str.end());

                rst.insert(rst.end(),str.begin(),str.end());
                str = "";
            }
            c--;
        }
        return rst;
    }
};
```

> 执行用时：4 ms, 在所有 C++ 提交中击败了58.38% 的用户
>
> 内存消耗：6.1 MB, 在所有 C++ 提交中击败了50.12% 的用户

题解也就就这个思路吧，，还挺好的


