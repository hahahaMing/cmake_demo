# [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

你现在手里有一份大小为 N x N 的『地图』（网格） `grid`，上面的每个『区域』（单元格）都用 `0` 和 `1` 标记好了。其中 `0` 代表海洋，`1` 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。

我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：`(x0, y0)` 和 `(x1, y1)` 这两个区域之间的距离是 `|x0 - x1| + |y0 - y1|` 。

如果我们的地图上只有陆地或者海洋，请返回 `-1`。

 

**示例 1：**

**![img](assets/1336_ex1.jpeg)**

```
输入：[[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。
```

**示例 2：**

**![img](assets/1336_ex2.jpeg)**

```
输入：[[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。
```

 

**提示：**

1. `1 <= grid.length == grid[0].length <= 100`
2. `grid[i][j]` 不是 `0` 就是 `1`

思路：

利用已经算出的结论减小遍历：

```python
def downLandIn(grid, x, y, d) -> bool:
    if not d and grid[y][x]: return True
    N = len(grid)
    for i in range(d + 1):
        xx = x + i
        yy = y + (d - i)
        if  xx < N and yy < N:
            if grid[yy][xx]:
                return True
    return False


class Solution:
    def maxDistance(self, grid: [[int]]) -> int:
        N = len(grid)
        record = []
        for i in range(N): record.append([-1] * N)
        # print(record)
        # record[0][1]=2
        # printGrid(record)
        rst = 0
        for y in range(N):
            for x in range(N):
                if y:
                    rg = record[y - 1][x]
                    record[y][x] = rg + 1
                else:
                    rg = max(x - 1, N - x) + N - 1
                if x:
                    rg = min(record[y][x - 1], rg)
                    record[y][x] = rg + 1
                for i in range(rg+1):
                    if downLandIn(grid, x, y, i):
                        record[y][x] = i
                        break
                if record[y][x] == -1:
                    return -1
                else:
                    rst = max(rst, record[y][x])
        # printGrid(record)
        if not rst: return -1
        return rst
```

> 执行用时 :952 ms, 在所有 Python3 提交中击败了28.92% 的用户
>
> 内存消耗 :13.9 MB, 在所有 Python3 提交中击败了17.65%的用户

利用不充分，存在n次遍历。

想到一个时间O(5n2)的方法：按4个象限方向遍历出4个表，然后叠加。

```python
class Solution:
    def maxDistance(self, grid: [[int]]) -> int:
        N = len(grid)

        def form(N):
            record = []
            for i in range(N): record.append([-1] * N)
            return record

        gg = []
        rec = form(N)
        for i in range(4): gg.append(form(N))
        atb = [[1, 1], [1, -1], [-1, 1], [-1, -1]]
        stp = [[0, 0], [0, N - 1], [N - 1, 0], [N - 1, N - 1]]
        end = [[N - 1, N - 1], [N - 1, 0], [0, N - 1], [0, 0]]
        rst = 0
        for i in range(4):
            y, x = stp[i]
            ey, ex = atb[i]
            while 0 <= y < N:
                while 0 <= x < N:
                    if grid[y][x]:
                        gg[i][y][x] = 0
                        x += ex
                        continue
                    if y == stp[i][0]:
                        if x != stp[i][1] and gg[i][y][x - ex] != -1:
                            gg[i][y][x] = gg[i][y][x - ex] + 1
                    else:
                        if x == stp[i][1]:
                            if gg[i][y - ey][x] != -1:
                                gg[i][y][x] = gg[i][y - ey][x] + 1
                        else:
                            if gg[i][y][x - ex] != -1:
                                if gg[i][y - ey][x] != -1:
                                    gg[i][y][x] = min(gg[i][y][x - ex], gg[i][y - ey][x]) + 1
                                else:
                                    gg[i][y][x] = gg[i][y][x - ex] + 1
                            elif gg[i][y - ey][x] != -1:
                                gg[i][y][x] = gg[i][y - ey][x] + 1
                    x += ex
                x = stp[i][1]
                y += ey
        for y in range(N):
            for x in range(N):
                temp = []
                for i in range(4):
                    if gg[i][y][x] != -1: temp.append(gg[i][y][x])
                if temp:
                    rst = max(rst, min(temp))
        if not rst: return -1
        return rst
```

> 执行用时 :1104 ms, 在所有 Python3 提交中击败了19.12% 的用户
>
> 内存消耗 :14.1 MB, 在所有 Python3 提交中击败了17.65%的用户

实际运行明明快了一个数量级。。

官方的解法的动态规划比我的好

从左上到右下一次，然后从右下到左上更新一次（利用上一次的数值，因为从右下开始，右下在上次里是完全正确的数值）最后只要取最大值就OK了。
