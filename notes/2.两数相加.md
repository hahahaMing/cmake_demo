# 2. 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

**思路**：

重点在于需要递归

为什么呢，因为正常的循环会出现先后矛盾的问题，所以需要递归，

递归就是在函数体里缩进n次，重点看：

1. 函数的重要执行部分的执行顺序（本例：链表的头插）、
2. 函数代入的值（具体到每个变量都是几）、
3. 以及最后一步函数如何有限化（讲退出函数有点容易让人误会，本例：用if使不满足条件时不调用自身，总执行数有限）

**自己做的答案**

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def adding2(l1: ListNode, l2: ListNode, carry) -> ListNode:
    if l1 != None or l2 != None or carry != 0:
        if l1 == None: l1 = ListNode(0)
        if l2 == None: l2 = ListNode(0)
        node_ = ListNode((l1.val + l2.val + carry) % 10)
        node_.next = adding2(l1.next,l2.next,(l1.val + l2.val + carry) // 10)
        return node_

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        return adding2(l1,l2,0)
```

> 执行用时 :116 ms, 在所有 Python3 提交中击败了7.73% 的用户
>
> 内存消耗 :13.2 MB, 在所有 Python3 提交中击败了55.17%的用户
>

菜，，但是看了别人的，思路都差不多，就是链表这个东西在python里不是很友好，很多内存管理很绕。

时间上可以继续优化

1. 利用判断（>10）来进位，比较比整除算得快
2. 把比较改为取反

尝试把比较改为取反
```python
def adding2(l1: ListNode, l2: ListNode, carry) -> ListNode:
    if l1 or l2 or carry:
        if not l1: l1 = ListNode(0)
        if not l2: l2 = ListNode(0)
        node_ = ListNode((l1.val + l2.val + carry) % 10)
        node_.next = adding2(l1.next,l2.next,(l1.val + l2.val + carry) // 10)
        return node_
```

> 执行用时 :64 ms, 在所有 Python3 提交中击败了94.58% 的用户
>
> 内存消耗 :13.3 MB, 在所有 Python3 提交中击败了55.17%的用户

PS: 验证了取反比直接比较快，利用如下代码
```python
import datetime

a = None
start = datetime.datetime.now()
for i in range(100000000):
    if a is not None:
        a = 1
    else:
        a = None

end = datetime.datetime.now()
print(end - start)

start = datetime.datetime.now()
for i in range(100000000):
    if not a:
        a = 1
    else:
        a = None
end = datetime.datetime.now()
print(end - start)
```

结果：

```
0:00:08.103332
0:00:07.248612
```

c++

```c++
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        auto nl1 = l1, nl2 = l2;
        ListNode *rst=new ListNode(0),*rst_cur = rst;
        int n1, n2, carry = 0, cur;
        while (nl1 != nullptr || nl2 != nullptr) {
            if (nl1) {
                n1 = nl1->val;
                nl1 = nl1->next;
            } else {
                n1 = 0;
            }
            if (nl2) {
                n2 = nl2->val;
                nl2 = nl2->next;
            } else {
                n2 = 0;
            }
            cur = n1 + n2 + carry;
            if (cur > 9) {
                cur -= 10;
                carry = 1;
            } else {
                carry = 0;
            }
            rst_cur->next = new ListNode(cur);
            rst_cur = rst_cur->next;

        }
        if (carry==1){
            rst_cur->next = new ListNode(1);
        }
        return rst->next;
    }
};
```

> 执行用时：52 ms, 在所有 C++ 提交中击败了8.79% 的用户
>
> 内存消耗：69.8 MB, 在所有 C++ 提交中击败了5.27% 的用户

题解代码比较干净规范

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) {
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            int sum = n1 + n2 + carry;
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            carry = sum / 10;
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        if (carry > 0) {
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```

但是时间和空间没啥区别




