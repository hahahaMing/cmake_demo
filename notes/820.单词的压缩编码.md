# [820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)

给定一个单词列表，我们将这个列表编码成一个索引字符串 `S` 与一个索引列表 `A`。

例如，如果这个列表是 `["time", "me", "bell"]`，我们就可以将其表示为 `S = "time#bell#"` 和 `indexes = [0, 2, 5]`。

对于每一个索引，我们可以通过从字符串 `S` 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

 

**示例：**

```
输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。
```

 

**提示：**

1. `1 <= words.length <= 2000`
2. `1 <= words[i].length <= 7`
3. 每个单词都是小写字母 。



思路1：

1. 或者定义一个”尾包含“

2. 遍历整个列表，如果被包含，就不加rst；如果包含，rst+=本词条长度-被包含词条长度

```python
class Solution:
    def minimumLengthEncoding(self, words: [str]) -> int:
        def backCover(w_short, w_long) -> int:
            """
            :param w_short:
            :param w_long:
            :return: if cover:l_long-l_short;else:-1
            """
            l = len(w_short)
            for i in range(l):
                if w_short[-1 - i] != w_long[-1 - i]:
                    return -1
            return len(w_long) - l

        rst, codes = 0, []
        for i in words:
            append = True
            if not codes:
                rst += len(i)
                codes.append(i)
                continue
            for id, j in enumerate(codes):
                if len(i) <= len(j):  # 判断是否被包含
                    if backCover(i, j) != -1: append = False
                else:  # 判断是否包含
                    if backCover(j, i) != -1:
                        codes[id] = i
                        rst += len(i) - len(j)
                        append = False
            if append:
                codes.append(i)
                rst+=len(i)
        return rst+len(codes)
```

超时了。。

思路2：

```python
class Solution:
    def minimumLengthEncoding(self, words: [str]) -> int:
        code = ''
        for i in range(7):
            for j in words:
                if len(j) == 7 - i and j+'#' not in code:
                    code = code + j + '#'
        return len(code)
```

> 执行用时 :336 ms, 在所有 Python3 提交中击败了21.74% 的用户
>
> 内存消耗 :14 MB, 在所有 Python3 提交中击败了8.33%的用户

题解：字典树（前缀树）

python实现用字典套字典
