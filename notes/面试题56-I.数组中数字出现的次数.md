# [面试题56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

 

**示例 1：**

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

**示例 2：**

```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

 

**限制：**

- `2 <= nums <= 10000`

```c++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int number = 0;
        vector<int> res(2,0);
        for(int num:nums) number ^= num;
        int pos = number&(-number);  // 找到最低位起1出现的位置
        for(int num:nums){
            if((num & pos) == pos) res[0] ^= num;
            else res[1]^=num;
        }
        return res;
    }
};
```

这题教做人了。

首先异或是符合交换律的，所以可以一次异或把相同的去掉，得到所有不同值异或的结果。

接着就是按位分组，得到答案两数异或结果后，找到最低位起1出现的位置，如果此位为1，分为一组，否则分为另一组，分别求异或得到最终结果。

**找到最低位起1出现的位置**
$$
\text {lowbit}=x \&(\sim x+1)=x \&(-x)
$$
解释：int负数二进制表示为：

1. 符号位（首位）变为1
2. 其余位取反
3. 整体+1

由于取反加一这个操作使得原数末尾的10000（最低位1与后面的0）不变而最低位1前的所有数被取反；

所以正负与会得到最低位1的位置。


