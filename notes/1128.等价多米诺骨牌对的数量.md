# [1128. 等价多米诺骨牌对的数量](https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/)

给你一个由一些多米诺骨牌组成的列表 `dominoes`。

如果其中某一张多米诺骨牌可以通过旋转 `0` 度或 `180` 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。

形式上，`dominoes[i] = [a, b]` 和 `dominoes[j] = [c, d]` 等价的前提是 `a==c` 且 `b==d`，或是 `a==d` 且 `b==c`。

在 `0 <= i < j < dominoes.length` 的前提下，找出满足 `dominoes[i]` 和 `dominoes[j]` 等价的骨牌对 `(i, j)` 的数量。

 

**示例：**

```
输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
输出：1
```

 

**提示：**

- `1 <= dominoes.length <= 40000`
- `1 <= dominoes[i][j] <= 9`

```c++
class Solution {
public:
    int numEquivDominoPairs(std::vector<std::vector<int>>& dominoes) {
        std::unordered_map<int,int> count;
        for(const auto&v:dominoes){
            int x = v[0],y=v[1];
            if(x>y)std::swap(x,y);
            if(count.find(x*10+y)==count.end())count[x*10+y]=1;
            else count[x*10+y]++;
        }
        int rst = 0;
        for(const auto&it:count){
            rst+=it.second*(it.second-1)/2;
        }
        return rst;
    }
};
```

> 执行用时：48 ms, 在所有 C++ 提交中击败了95.08% 的用户
>
> 内存消耗：16.8 MB, 在所有 C++ 提交中击败了98.18% 的用户

题解用的数组，我用的哈希表。


