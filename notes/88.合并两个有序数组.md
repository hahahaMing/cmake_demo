# 88. 合并两个有序数组
给你两个有序整数数组 `nums1`<em> </em>和 `nums2`，请你将 `nums2`<em> </em>合并到 `nums1`<em> </em>中<em>，</em>使 `nums1`<em> </em>成为一个有序数组。

初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n`<em> </em>。你可以假设 `nums1`<em> </em>的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

 

**示例 1：**

**输入：**nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
**输出：**[1,2,2,3,5,6]


**示例 2：**

**输入：**nums1 = [1], m = 1, nums2 = [], n = 0
**输出：**[1]




**提示：**


- `nums1.length == m + n`

- `nums2.length == n`

- `0 <= m, n <= 200`

- `1 <= m + n <= 200`

- `-10 ^ 9 <= nums1[i], nums2[i] <= 10 ^ 9`


## 我的代码
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int i = 0;i<n;i++){
            nums1[m+i] = nums2[i];
        }
        sort(nums1.begin(),nums1.end());
    }
};
```
> 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户
>
> 内存消耗：8.9 MB, 在所有 C++ 提交中击败了36.62%的用户

## 题解

逆向双指针，从两个数组最后开始遍历，较大者放入nums1末尾，这样永远都有空间

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
};
```

