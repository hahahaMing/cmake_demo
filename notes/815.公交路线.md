# 815. 公交路线
给你一个数组 `routes` ，表示一系列公交线路，其中每个 `routes[i]` 表示一条公交线路，第 `i` 辆公交车将会在上面循环行驶。


- 例如，路线 `routes[0] = [1, 5, 7]` 表示第 `0` 辆公交车会一直按序列 `1 ->; 5 ->; 7 ->; 1 ->; 5 ->; 7 ->; 1 ->; ...` 这样的车站路线行驶。


现在从 `source` 车站出发（初始时不在公交车上），要前往 `target` 车站。 期间仅可乘坐公交车。

求出 **最少乘坐的公交车数量** 。如果不可能到达终点车站，返回 `-1` 。

 

**示例 1：**

**输入：**routes = [[1,2,7],[3,6,7]], source = 1, target = 6
**输出：**2
**解释：**最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 


**示例 2：**

**输入：**routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
**输出：**-1




**提示：**


- `1 <= routes.length <= 500`.

- `1 <= routes[i].length <= 10 ^ 5`

- `routes[i]` 中的所有值 **互不相同**

- `sum(routes[i].length) <= 10 ^ 5`

- `0 <= routes[i][j] < 10 ^ 6`

- `0 <= source, target < 10 ^ 6`


## 我的代码

```c++
class Solution {
    int n;
    vector<int> rcd;           // 记录到达线路i需要公交数量
    vector<vector<bool>> grid; // map for routes

  public:
    int numBusesToDestination(vector<vector<int>> &routes, int source,
                              int target) {
        if(source==target)return 0;
        // 1，建图，只关心线路是否联通
        n = routes.size();
        grid = vector<vector<bool>>(
            n, vector<bool>(n, false)); // route_i and route_j is connected?
        unordered_map<int, vector<int>> sites;// 记录每站对应线路
        rcd = vector<int>(n, 0);
        for (int i = 0; i < n; ++i) {
            grid[i][i] = true;
            for (int x : routes[i]) {
                if (sites.find(x) != sites.end()) {
                    for (int r : sites[x]) {
                        grid[i][r] = true;
                        grid[r][i] = true;
                    }
                }
                sites[x].emplace_back(i);
            }
        }
        // 2. bfs ，通过起终点所在线路进行搜索，填充rcd数组
        queue<int> que;
        int count = 1;
        for (int x : sites[source]) {
            que.push(x);
        }
        while (!que.empty()) {
            int len = que.size();
            for (int i = 0; i < len; ++i) {
                int tmp = que.front();
                que.pop();
                if (rcd[tmp] == 0) {
                    rcd[tmp] = count;
                    for (int j = 0; j < n; ++j) {
                        if (grid[tmp][j] && rcd[j] == 0) {
                            que.push(j);
                        }
                    }
                }
            }
            count++;
        }
        //

        int rst = 501;
        for (int x : sites[target]) {
            if(rcd[x]!=0)
                rst = min(rst, rcd[x]);
        }
        return rst == 501 ? -1 : rst;
    }
};
```
> 执行用时：204 ms, 在所有 C++ 提交中击败了79.90%的用户
>
> 内存消耗：49.8 MB, 在所有 C++ 提交中击败了76.41%的用户

## 题解

```c++
class Solution {
public:
    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {
        if (source == target) {
            return 0;
        }

        int n = routes.size();
        vector<vector<int>> edge(n, vector<int>(n));
        unordered_map<int, vector<int>> rec;
        for (int i = 0; i < n; i++) {
            for (int site : routes[i]) {
                for (int j : rec[site]) {
                    edge[i][j] = edge[j][i] = true;
                }
                rec[site].push_back(i);
            }
        }

        vector<int> dis(n, -1);
        queue<int> que;
        for (int bus : rec[source]) {
            dis[bus] = 1;
            que.push(bus);
        }
        while (!que.empty()) {
            int x = que.front();
            que.pop();
            for (int y = 0; y < n; y++) {
                if (edge[x][y] && dis[y] == -1) {
                    dis[y] = dis[x] + 1;
                    que.push(y);
                }
            }
        }

        int ret = INT_MAX;
        for (int bus : rec[target]) {
            if (dis[bus] != -1) {
                ret = min(ret, dis[bus]);
            }
        }
        return ret == INT_MAX ? -1 : ret;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/bus-routes/solution/gong-jiao-lu-xian-by-leetcode-solution-yifz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 标签
[0.典型题.md](0.典型题.md)
[815.公交路线.md](815.公交路线.md)

 广度优先搜索

## 知识点



## 错误用例

in：

[[1,7],[3,5]]
5
5

out:

0

