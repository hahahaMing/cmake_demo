# [514. 自由之路](https://leetcode-cn.com/problems/freedom-trail/)

视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。

给定一个字符串 **ring**，表示刻在外环上的编码；给定另一个字符串 **key**，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的**最少**步数。

最初，**ring** 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 **key** 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 **key** 中的所有字符。

旋转 **ring** 拼出 key 字符 **key[i]** 的阶段中：

1. 您可以将 **ring** 顺时针或逆时针旋转**一个位置**，计为1步。旋转的最终目的是将字符串 **ring** 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 **key[i] 。**
2. 如果字符 **key[i]** 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 **1 步**。按完之后，您可以开始拼写 **key** 的下一个字符（下一阶段）, 直至完成所有拼写。

**示例：**

 

![img](assets/ring.jpg)

```
输入: ring = "godding", key = "gd"
输出: 4
解释:
 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。
```

**提示：**

1. **ring** 和 **key** 的字符串长度取值范围均为 1 至 100；
2. 两个字符串中都只有小写字符，并且均可能存在重复字符；
3. 字符串 **key** 一定可以由字符串 **ring** 旋转拼出。

```c++
class Solution {
    // 暴力搜索超时了，所以用动态规划，
    // 这里dp存储<当前字符在ring中的位置，到达此位置当前字符的最少步数>，
    // 比如当前字符为"g"，上一个dp为开头设为{<0,0>}，则dp需要更新为{<0,1>,<6,2>}。
    std::map<char, std::vector<int>> ring_hash;
    int ring_length;
public:
    int findRotateSteps(std::string ring, const std::string &key) {
        for (int i = 0; i < ring.size(); ++i) {
            ring_hash[ring[i]].emplace_back(i);
        }
        ring_length = ring.size();
        std::vector<std::pair<int, int>> dp = {std::make_pair(0, 0)}, new_dp = {};
        for (char k:key) {
            for (int next_ring_location : ring_hash[k]) {
                int steps = 10000, tmp_step;
                for (auto pr:dp) {
                    tmp_step = std::min(abs(next_ring_location - pr.first) + 1,
                                        ring_length + 1 - abs(next_ring_location - pr.first));
                    steps = std::min(steps, tmp_step + pr.second);
                }
                new_dp.emplace_back(next_ring_location, steps);
            }
            dp = new_dp;
            new_dp = {};
        }
        int rst = 10000;
        for (auto pr:dp) {
            if (pr.second < rst)rst = pr.second;
        }
        return rst;
    }
};
```

> 执行用时：40 ms, 在所有 C++ 提交中击败了55.25% 的用户
>
> 内存消耗：7.7 MB, 在所有 C++ 提交中击败了65.75% 的用户

题解：差不多。


