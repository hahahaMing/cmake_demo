#  5. 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
示例 2：
```
输入: "cbbd"
输出: "bb"
```

特例：

`"abababa" -> "abababa"`

`"cbbb" -> "bbb"`

`'' -> ''`

**思路**：

1. 回文：正看反看都一样
2. 暴力法

代码：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        l = s.__len__()
        ss=""
        for i in range(0,l):
            for j in range(0,i+1):
                ss = s[j:l-i+j+1]
                sv = ss[::-1]
                if ss == sv:
                    return ss
        return ss
```

>执行用时 :5440 ms, 在所有 Python3 提交中击败了16.11% 的用户
>
>内存消耗 :12.9 MB, 在所有 Python3 提交中击败了63.25%的用户

### **Manacher 算法**

参考这个：[动态规划、Manacher 算法](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)
**自己写的代码**：


```python
def add_char(s,c):
    ss = c
    for _ in s:
        ss = ss + _ + c
    return ss

def delete_char(ss):
    size = len(ss)
    s=''
    for i in range(1,size):
        if i&1:s = s+ss[i]
    return s

def center_spread(s, center, start):
    size = len(s)
    i = center - 1 - start
    j = center + 1 + start
    step = start
    while i >= 0 and j < size and s[i] == s[j]:
        step += 1
        i = i - 1
        j = j + 1
    return step


class Solution:

    def longestPalindrome(self, s: str) -> str:
        # todo insert'#'
        ss = add_char(s,'#')
        # form 1 to l-1, calculate p (this char as center the longestP's length
        l = len(ss)
        p = [0] * l
        maxRight = 0
        center = 0
        p_max = 0
        longest_center = 0
        for i in range(1, l - 1):  # use a complicated way to traverse
            if i >= maxRight:
                p[i] = center_spread(ss, i, 0)
                if p[i] + i > maxRight:
                    center = i
                    maxRight = i + p[i]
            else:
                mirror = 2 * center - i
                if p[mirror] < maxRight - i:
                    p[i] = p[mirror]
                if p[mirror] == maxRight - i:
                    p[i] = center_spread(ss, i, p[mirror])  # start spread from a specific value
                    if p[i] + i > maxRight:
                        center = i
                        maxRight = i + p[i]
                if p[mirror] > maxRight - i:
                    p[i] = maxRight - i
            if p[i] > p_max:
                p_max = p[i]
                longest_center = i
        # minus "#" and return
        sss = ss[longest_center - p[longest_center]:longest_center + p[longest_center]+1]
        return delete_char(sss)
```
>执行用时 :116 ms, 在所有 Python3 提交中击败了90.77% 的用户
内存消耗 :13.5 MB, 在所有 Python3 提交中击败了52.65%的用户

**反思**：

1. `p = [0 for _ in range(t_len)]`快速建立给定长度0数组
2. 写的那个delete太蠢了，正解应该通过center推算答案在原字符串的起点与终点位置

自己写的c++代码：

```c++
class Solution {
public:
    std::string longestPalindrome(std::string s) {
        // std::cout << s << std::endl;
        //动态规划：
        // 1 添加分隔符
        std::string ss = "#";
        for (auto i:s) {
            ss += i;
            ss += "#";
        }
        // 2 动态规划辅助数组p
        int max_r=0, center=0;//当前向右扩展的最远边界，和最远边界的最长回文中心
        int len = ss.size();
        std::vector<int> p(len);
        int l, r;
        int mirror;
        for (int j = 0; j < len; ++j) {
            if (j >= max_r) {
                //重心扩散法 扫描
                l = j - 1;
                r = j + 1;
                while (l >= 0 && r < len && ss[l] == ss[r]) {
                    l--;
                    r++;
                    p[j]++;
                }
                max_r = j+p[j];
                center = j;
            } else {
                //根据p数组 更新p数组
                mirror = 2*center-j;
                if (p[mirror]<max_r-j){
                    p[j] = p[mirror];
                } else if (p[mirror]==max_r-j){
                    p[j] = p[mirror];
                    l = j-p[mirror]-1;
                    r = j+p[mirror]+1;
                    while (l >= 0 && r < len && ss[l] == ss[r]) {
                        l--;
                        r++;
                        p[j]++;
                    }
                    max_r = j+p[j];
                    center = j;
                }else{
                    p[j] = max_r-j;
                }
            }
        }
        auto ml = max_element(p.begin(), p.end());
        int step = *ml,location = (ml-p.begin()-step)>>1;

        return s.substr(location,step);
        // return s;
    }
};
```

> 执行用时 :12 ms, 在所有 C++ 提交中击败了93.38% 的用户
>
> 内存消耗 :7.8 MB, 在所有 C++ 提交中击败了100.00%的用户
