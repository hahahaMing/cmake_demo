# [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 *k* 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

**注意：**字符串长度 和 *k* 不会超过 104。

 

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

**示例 2：**

```
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
```

```c++
class Solution {
public:
    int characterReplacement(std::string s, int k) {
        if (s.empty())return 0;
        //滑动窗口
        int l = 0, r = 1;
        int n = s.size();
        std::vector<int> rcd(26, 0);
        rcd[s[0] - 'A']++;
        while (r < n) {
            rcd[s[r] - 'A']++;
            if (r - l + 1 - *std::max_element(rcd.begin(), rcd.end()) > k) {
                rcd[s[l] - 'A']--;
                l++;
            }
            r++;
        }
        return r - l;
    }
};
```

> 执行用时：12 ms, 在所有 C++ 提交中击败了49.42% 的用户
>
> 内存消耗：6.9 MB, 在所有 C++ 提交中击败了89.52% 的用户

题解的最大值更新有优化

```c++
class Solution {
public:
    int characterReplacement(string s, int k) {
        vector<int> num(26);
        int n = s.length();
        int maxn = 0;
        int left = 0, right = 0;
        while (right < n) {
            num[s[right] - 'A']++;
            maxn = max(maxn, num[s[right] - 'A']);
            if (right - left + 1 - maxn > k) {
                num[s[left] - 'A']--;
                left++;
            }
            right++;
        }
        return right - left;
    }
};
```

maxn严格表示窗口内最多的字母个数,因为当left左移，所删除字母必然不是窗口内最多的字母，因为最多的字母没有必要删除。

但当maxn被更新时maxn严格表示窗口内最多的字母个数，这时窗口长度被严格正确的更新，所以每次窗口长度的更新都严格正确，答案




