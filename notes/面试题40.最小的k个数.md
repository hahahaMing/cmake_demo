# [面试题40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 

**示例 1：**

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

**示例 2：**

```
输入：arr = [0,1,2,1], k = 1
输出：[0]
```

 

**限制：**

- `0 <= k <= arr.length <= 10000`
- `0 <= arr[i] <= 10000`

```python
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        return arr[:k]
```

> 执行用时 :64 ms, 在所有 Python3 提交中击败了82.62% 的用户
>
> 内存消耗 :14.4 MB, 在所有 Python3 提交中击败了100.00%的用户

```python
from math import log


class Solution:
    def getLeastNumbers(self, arr: [int], k: int) -> [int]:
        if not k :return []
        n = len(arr)
        c1 = k * (log(k, 2) + n - k)
        c2 = n * log(n, 2)
        if c1 < c2:
            rst = arr[:k]
            rst.sort()
            rst = rst[::-1]
            for i in range(k, n):
                if arr[i] < rst[0]:
                    rst[0] = arr[i]
                    for j in range(1, k):
                        if rst[j - 1] < rst[j]:
                            rst[j - 1], rst[j] = rst[j], rst[j - 1]
                        else:
                            break
            return rst
        else:
            arr.sort()
            return arr[:k]
```

> 执行用时 :52 ms, 在所有 Python3 提交中击败了96.82% 的用户
>
> 内存消耗 :14.7 MB, 在所有 Python3 提交中击败了100.00%的用户

### **BFPRT算法**

就是优化快排利用那个值的选择方式，百度很多代码，里面坑很多，用c++的时候可以来复习一下。

```python
def InsertSort(arr: [int], left: int, right: int) -> int:
    """
    对数组中[left...right]插入排序并返回[left...right]的中位数
    """
    for i in range(left + 1, right + 1):
        temp = arr[i]
        j = i - 1
        while j >= left and arr[j] > temp:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = temp
    return ((right - left) >> 1) + left



def Partition(arr, left, right, pivot_index):
    """
    利用主元下标 pivot_index 进行对数组 array[left, right] 划分，并返回
    划分后的分界线下标。
    :param arr:
    :param left:
    :param right:
    :param pivot_index:
    :return:
    """
    arr[pivot_index], arr[right] = arr[right], arr[pivot_index]  # 把主元放置于末尾
    partition_index = left  # 跟踪划分的分界线
    for i in range(left, right):
        if arr[i] < arr[right]:
            # 比主元小的都放在左侧
            arr[partition_index], arr[i] = arr[i], arr[partition_index]
            partition_index += 1
    arr[partition_index], arr[right] = arr[right], arr[partition_index]  # 最后把主元换回来
    return partition_index


def BFPRT(arr, left, right, k):
    """
    求数组arr下标 left到 right中的第 k个数
    """
    if right - left < 5:
        InsertSort(arr, left, right)
        return arr[left + k - 1]
    sub_right = left - 1
    for i in range(left, right - 3, 5):
        index = InsertSort(arr, i, i + 4)
        sub_right += 1
        arr[sub_right], arr[index] = arr[index], arr[sub_right]
    # 以上代码将整个数组分为以5为单位的组，分别求中位数逐个放到数组最前面
    # print(arr)
    # print("---"*20)
    mid = (left + sub_right) >> 1
    # BFPRT(arr, left, sub_right, mid - left + 1)
    m = Partition(arr, left, right, mid)
    cur = m - left + 1
    if k == cur:
        return arr[m]
    elif k < cur:
        return BFPRT(arr, left, m - 1, k)
    else:
        return BFPRT(arr, m + 1, right, k - cur)

class Solution:
    def getLeastNumbers(self, arr: [int], k: int) -> [int]:
        if not k: return []
        BFPRT(arr,0,len(arr)-1,k)
        return arr[:k]
```
