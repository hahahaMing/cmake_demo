# [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。

返回符合要求的 **最少分割次数** 。

 

**示例 1：**

```
输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

**示例 2：**

```
输入：s = "a"
输出：0
```

**示例 3：**

```
输入：s = "ab"
输出：1
```

 

**提示：**

- `1 <= s.length <= 2000`
- `s` 仅由小写英文字母组成

```c++
class Solution {
    std::string com_s;
    std::vector<std::vector<int>> rcd;

    bool is_palindrome(int i, int j) {
        if (rcd[i][j]==1)return true;
        if (rcd[i][j]==-1)return false;
        bool rst;
        if (i == j) {
            rst = true;
        } else {
            if (com_s[i] == com_s[j]) {
                if (i + 1 == j || is_palindrome(i + 1, j - 1)) rst = true;
                else rst = false;
            } else rst = false;
        }
        if (rst) rcd[i][j] = 1;
        else rcd[i][j] = -1;
        return rst;
    }

public:
    int minCut(std::string s) {
        if (s.empty())return 0;
        int n = s.size();
        com_s = s;
        rcd = std::vector<std::vector<int>>(n, std::vector<int>(n, 0));
        std::vector<int> min_num(n, 1);//记录前i个字符中最少回文子串的数量
        for (int i = 1; i < n; ++i) {
            if (is_palindrome(0, i))continue;
            min_num[i] = i + 1;
            for (int j = 1; j <= i; ++j) {
                if (is_palindrome(j, i)) {
                    if (min_num[j - 1] + 1 < min_num[i])
                        min_num[i] = min_num[j - 1] + 1;
                }
            }
        }
        return min_num.back() - 1;
    }
};
```

> 执行用时：84 ms, 在所有 C++ 提交中击败了38.10% 的用户
>
> 内存消耗：19.2 MB, 在所有 C++ 提交中击败了24.47% 的用户

题解基本一样，可以优化一下：

```c++
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        vector<vector<int>> g(n, vector<int>(n, true));

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                g[i][j] = (s[i] == s[j]) && g[i + 1][j - 1];
            }
        }

        vector<int> f(n, INT_MAX);
        for (int i = 0; i < n; ++i) {
            if (g[0][i]) {
                f[i] = 0;
            }
            else {
                for (int j = 0; j < i; ++j) {
                    if (g[j + 1][i]) {
                        f[i] = min(f[i], f[j] + 1);
                    }
                }
            }
        }

        return f[n - 1];
    }
};
```




