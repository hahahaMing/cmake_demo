# [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

```
输入: [3,2,3]
输出: 3
```

**示例 2:**

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

思路：建立hash表，满足条件就输出

```python
class Solution:
    def majorityElement(self, nums: [int]) -> int:
        hash = {}
        n2 = len(nums)//2
        for i in nums:
            if i in hash:
                hash[i] += 1
            else:
                hash[i] = 1
            if hash[i] == n2+1:
                return i
```

> 执行用时 :92 ms, 在所有 Python3 提交中击败了78.21% 的用户
>
> 内存消耗 :15.2 MB, 在所有 Python3 提交中击败了5.04%的用户

看题解：

1.数组排序，中间肯定是题解，牛逼

```python
class Solution:
    def majorityElement(self, nums: [int]) -> int:
        nums.sort()
        return nums[len(nums)//2]
```

> 执行用时 :52 ms, 在所有 Python3 提交中击败了90.33% 的用户
>
> 内存消耗 :15.1 MB, 在所有 Python3 提交中击败了5.04%的用户



### **摩尔投票法**

众数出现的次数>其他数字出现次数之和

    初始化res=0，count=0
    
    遍历数组：
    若count==0，则将res更新为nums[i]，并令count=1
    否则：
    若nums[i]==res，令count+=1
    若nums[i]!=res，令count−=1
    
    若最终count>0，则返回res

复杂度分析

时间复杂度：O(n)
**空间复杂度：O(1)**

自己写一遍

```python
class Solution:
    def majorityElement(self, nums: [int]) -> int:
        count = 0
        for i in nums:
            if not count:
                res = i
            if i == res:
                count += 1
            else:
                count -= 1
        return res
```

> 执行用时 :44 ms, 在所有 Python3 提交中击败了95.58% 的用户
>
> 内存消耗 :15.2 MB, 在所有 Python3 提交中击败了5.04%的用户
