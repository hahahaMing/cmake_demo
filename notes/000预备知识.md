# 预备知识

##  一、算法知识

### 1.1 算法的时间复杂度和空间复杂度详解

刷第一道题，看懂了算法却比较不出好坏，故学习。

[算法的时间复杂度和空间复杂度详解](https://blog.csdn.net/yjclsx/article/details/86612659)

读这篇文章，简练一下：

**1 时间复杂度：**

1. 找出算法中的基本语句；

　　算法中执行次数最多的那条语句就是基本语句，**通常是最内层循环的循环体。**

2. 计算基本语句的执行次数的数量级；
3. 用大Ο记号表示算法的时间性能。 
4. 程序复杂时的计算法则：
   1. 输入、输出、赋值  O(1) 
   2. 顺序结构 求和
   3. 选择结构 主要是选择后的时间，检验条件时间 O(1) 
   4. 循环结构 乘法法则

 **2 空间复杂度：**

1. 存储算法本身所占用的存储空间
2. 算法的输入输出数据所占用的存储空间
3. 算法在运行过程中临时占用的存储空间

### 1.2 广度优先搜索

问题出在 [695. 岛屿的最大面积](## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/))

这个帖子牛逼，可以做成更直观的看，[图的广度优先搜索（BFS）和深度优先搜索（DFS）算法解析](https://blog.csdn.net/weixin_40953222/article/details/80544928)

 ![DFS 与 BFS](F:/日常学习/leetcode.assets/725e473003c35e3be67ac6177cc6744fa04b0466795b5e69c7d673f626206b86-file_1583293748397.jpg) 

如何写（最短路径的） BFS 代码

我们都知道 BFS 需要使用**队列**(进出在两个地方），代码框架是这样子的（伪代码）：

```python
while queue 非空:
	node = queue.pop()
    for node 的所有相邻结点 m:
        if m 未访问过:
            queue.push(m)
```

### 1.3 快排

先取一个数，让其左边都比他小，右边都比他大，然后把左右各当成数组重复上述过程递归。

 ![快排图](F:/日常学习/leetcode.assets/b7003af33a87e950707fdf2110385343fbf2b416-1584683286835.gif) 

```python
def quick_sort(data):    
    """快速排序"""    
    if len(data) >= 2:  # 递归入口及出口        
        mid = data[len(data)//2]  # 选取基准值，也可以选取第一个或最后一个元素        
        left, right = [], []  # 定义基准值左右两侧的列表        
        data.remove(mid)  # 从原始数组中移除基准值        
        for num in data:            
            if num >= mid:                
                right.append(num)            
            else:                
                left.append(num)        
        return quick_sort(left) + [mid] + quick_sort(right)    
    else:        
        return data
 
# 示例：
array = [2,3,5,7,1,4,6,15,5,2,7,9,10,15,9,17,12]
print(quick_sort(array))
# 输出为[1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 9, 9, 10, 12, 15, 15, 17]
```

### 1.4 插入排序

 ![img](F:/日常学习/leetcode.assets/d0c8a786c9177f3eee69fa7e70cf3bc79f3d5667.gif) 

### 1.5 二叉树操作

![1590083250326](F:/日常学习/leetcode.assets/1590083250326.png)

### 1.6 字典序

只有比较关系，比如"aabcc"与"abacc"由于比到第二个前一个比较小就停止比较，结果为前一个小。

### 1.7 并查集

 1) 初始化:初始的时候每个结点各自为一个集合,father[i]表示结点 i 的父亲结点,如果 father[i]=i,我们认为这个结点是当前集合根结点。

```cpp
void init() {
    for (int i = 1; i <= n; ++i) {
        father[i] = i;
    }
}
```

2) 查找:查找结点所在集合的根结点,结点 x 的根结点必然也是其父亲结点的根结点。

```cpp
int get(int x) {
    if (father[x] == x) { // x 结点就是根结点
        return x; 
    }
    return get(father[x]); // 返回父结点的根结点
}
```

3) 合并:将两个元素所在的集合合并在一起,通常来说,合并之前先判断两个元素是否属于同一集合。

```cpp
void merge(int x, int y) {
    x = get(x);
    y = get(y);
    if (x != y) { // 不在同一个集合
        father[y] = x;
    }
}
```

上面三个操作是并查集常用的操作

前面的并查集的复杂度实际上在有些极端情况会很慢。比如树的结构正好是一条链，那么最坏情况下，每次查询的复杂度达到了O(n) 。这并不是我们期望的结果。**路径压缩**的思想是，**我们只关心每个结点的父结点，而并不太关心树的真正的结构。**

这样我们在一次查询的时候，可以把查询路径上的所有结点的father[i]都赋值成为根结点。只需要在我们之前的查询函数上面进行很小的改动``

```cpp
int get(int x) {
    if (father[x] == x) { // x 结点就是根结点
        return x; 
    }
    return father[x] = get(father[x]); // 返回父结点的根结点，并另当前结点父结点直接为根结点
}
```

![img](F:/日常学习/leetcode.assets/20180609171300274)

路径压缩在实际应用中效率很高,其一次查询复杂度平摊下来可以认为是一个常数。并且在实际应用中,我们基本都用带路径压缩的并查集。




## 二、一些语法--python

### 2.1 代码阅读

> 一般只存在于代码的阅读中，暂时不常用，稍作记录，后面如果觉得可以，就把他应用后面两项。

#### 2.1.1 [python3——“->”的含义](https://www.cnblogs.com/gaoquanquan/p/9455952.html) 		

`->:`标记返回函数注释,信息作为`.__annotations__`属性提供,`__annotations__`属性是字典。键`return`是用于在箭头后检索值的键。但是在Python中`3.5`，[PEP 484 - Type Hints](https://www.python.org/dev/peps/pep-0484/)附加了一个含义：`->`用于指示函数返回的类型。它似乎也将在未来版本中强制执行。

例子:

　　输入：

```python
def test() -> [1, 2, 3, 4, 5]:
    pass


print(test.__annotations__)
```

　　输出：

　　　　{'return': [1, 2, 3, 4, 5]}

#### 2.1.2 `str[-1:1]`为啥是空字符

可能是因为不知道啥意思吧：

一些尝试：

```python
>>> h = 'sdfsf'
>>> h[-1:1]
''
>>> h[-1:]
'f'
>>> h[-1:2]
''
>>> h[-1:0]
''
>>> h[-1:n]
Traceback (most recent call last):
  File "<pyshell#15>", line 1, in <module>
    h[-1:n]
NameError: name 'n' is not defined
>>> h[-1:-2]
''
>>> h[-2:1]
''
>>> h[-3:]
'fsf'
>>> h[-2:]
'sf'
>>> h[-2:0]
''
```

#### 2.1.3 820题代码阅读

```python
class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        good = set(words)# set建立无重复序列
        for word in words:
            for k in range(1, len(word)):
                good.discard(word[k:])# disgard删除（）里的元素

        return sum(len(word) + 1 for word in good)
```

```python
class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words = list(set(words)) #remove duplicates
        #Trie is a nested dictionary with nodes created
        # when fetched entries are missing
        Trie = lambda: collections.defaultdict(Trie)#初始化字典，对没见过的key自动添加默认值
        trie = Trie()

        #reduce(..., S, trie) is trie[S[0]][S[1]][S[2]][...][S[S.length - 1]]
        nodes = [reduce(dict.__getitem__, word[::-1], trie)
                 for word in words]
        #看结果就是建立了字典树。。。

        #Add word to the answer if it's node has no neighbors
        return sum(len(word) + 1
                   for i, word in enumerate(words)
                   if len(nodes[i]) == 0)
```



### 2.2 代码提速

#### 2.2.1 位操作会快很多

1. 移位除2：`a>>1`等价于`a//2`但会快很多;
2. 与取余：`a&1`$\Harr$`a%2`;

### 2.3 代码整洁

#### 2.3.1 print不换行

```python
print('输出内容',end='')
```

#### 2.3.2 快速建立给定长度0数组

```python
p = [0 for _ in range(t_len)]
```

#### 2.3.4  三目运算 

```python
#一般的写法
 if (x == y):
     print("两数相同！")
 elif(x > y):
     print("较大的数为：",x)
 else:
     print("较大的数为：",y)
            
# 三目运算符写法
print(x if(x>y) else y)
```

#### 2.3.5 enumerate()

`for i, l in enumerate(目标数组)`

可以同时取出index和值

#### 2.3.6 用list

`stack = [(i, j)]`可以建立一个（i，j）为元素的数组

#### 2.3.7 for else

```python
for i in ():
    。。。
else：# 若for循环没有正常执行完成就执行下面语句（比如中途有break）
	。。。
```

c++里也有，不建议总用，好像对代码阅读不友好。

#### 2.3.8 别忘了库

`math.gcd`求两个数的最大公约数，返回整数；

`collections.Counter`统计字符串（数字）种类及数量，返回字典；

`functools.reduce`逐次对上次函数结果与当前序列元素应用函数；

- `reduce(function, sequence)`
- 例如 reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) 计算为((((1+2)+3)+4)+5)

### 2.4 常用语法

#### 2.4.1 字典操作

[collections.defaultdict()的使用](https://blog.csdn.net/yangsong95/article/details/82319675)可以避免 【当Key不存在时，会引发‘KeyError’异常 】

> - 字典查找速度快
> - 字典是无序的；（python 3.6以上版本有序）
> - 字典支持乘加、成员检查、长度、最小值、最大值、嵌套；
> - 字典值不支持列表、元组、索引、切片、元素赋值跟切片赋值；
> - 字典通过大括号表示；
> - 字典的内容是项；项由键和值组成，中间用冒号隔开；项和项之间用逗号隔开；需要注意键必须是唯一的；
> - 字典的意义是让用户能够快速的找到特定的单词（键），以获悉其定义（值）；
> - 字典通过键来进行查看值的内容
> - 字典的值可以是字符串、数字、字典

1. 字典的赋值

```
dict1 = {'key1':'value1', 'key2':'value2'}
```

2. 字典的添加

```
dic1 = {'name': 'liangxiao', 'age': 24}
dic1.setdefault('work', 'IT')            # 原有key存在值，则不操作

dic1 = {'name': 'liangxiao', 'age': 24}
dic1['work'] = 'IT'                      # 原有key存在值，则覆盖
```

3. 字典的更新

```
dic1 = {'name': 'liangxiao'}
dic2 = {'age': 18}
dic2.update(dic1)        　　　　　　　　# 将dic1里面的内容更新到dic2里面
```

```
dic1 = {'name': 'liangxiao', 'age': 24}
dic1['name'] = 'LIANGXIAO'            # 更新value的内容
```

4. 字典的删除

```
dic1 = {'name': 'liangxiao', 'age': 24}
dic1.pop('name')            # 根据key进行键值对删除，可设置返回值，没有找到相应的key默认会报错

dic1 = {'name': 'liangxiao', 'age': 24}
del dic1                    # 删除字典

dic1 = {'name': 'liangxiao', 'age': 24}
dic1.clear()                # 清空字典

dic1 = {'name': 'liangxiao', 'age': 24}
dic1.popitem()              # 随机删除任意一个键值对
```

5. 通过列表转换字典

```
items = [('name', 'xiao'), ('age', 25)]
Dict_ = dict(items)
```

6. 字典的查看

```
dic1.values()　　　　　　  # 查看所有的value
dic1.keys()　　　　　　　　 # 查看所有的key
print(dict)              # 打印字典所有
dic1.get('name')         # 查找指定的key的value，没有则返回None
dic1.items()             # 一组一组的查找所有内容
```

## 三、一些软件用法

### 3.1 pycharm

1. 无法debug可能是程序没加断点。

2. [pycharm添加文件头注释](https://www.cnblogs.com/yellow-hgy/p/10208759.html)

3. #### pycharm中批量替换                               

   ctrl /command + f 搜索
   ctrl /command + r 批量替换

## 四、一些疑问

### 4.1 发现两次提交会差很多时间？



## 五、C++记录

### 5.1 string操作

1 赋值

```c++
string s="";
string a="abcdefg";

//将字符串a完全赋值给新字符串s
s.assign(a);

//将字符串a的一部分赋值给新的字符串s
//start是截取字符串的首位置，len是截取字符串的长度
s.substr(start,len);
s.assign(a,start,len);

//对字符串s赋相同的n个初值
s.assign(n,'x'); 
//如给s赋10个字符a写法如下：
s.assign(10,'a');
```

转为char数组

```c++
rst = str.c_str()
```

比较

```c++

```

反转

```c++
std::reverse(str.begin(),str.end());
```



### 5.2 map 操作

```c++
    std::map<int,int>m;
    m[1]=11;
    m[2]=22;
    m[1]=33;
    std::map<int,int>t = m;
    std::cout<<t[2];
```

### 5.3 vector 操作

删除

```c++
iterator erase(iterator position);

iterator erase(iterator first, iterator last);//迭代器指向下一个
```

sort

```c++
vector<int> a;
sort(a.begin(), a.end());//56题中对vector<vector<int>>也可直接按首位数字排序，神了。
```

拼接

```c++
v1.insert(v1.end(),v2.begin(),v2.end());
```

初始化

```c++
 vector<vector<int> > newOne(r, vector<int>(c, 0));
```





### 5.4 链表

结构

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
```

### 5.5 整形最大最小值

```c++
int max = LONG_MIN;//2147483647
int min = LONG_MAX;//-2147483648
```

### 5.6 for

```c++
       想要拷贝元素 for(auto x:range)

       想要修改元素 for(auto &x:range)

       想要只读元素 for(const auto& x:range)       
```

### 5.7 switch

switch case本质是通过在汇编的时候生成跳转表来指示case的地址，通常编译器都会对跳转表进行优化[2](https://blog.csdn.net/weixin_43862101/article/details/84859437#fn2)，所以它所有case都可以通过少量判断就跳转到对应符合条件的case，对于每一个case的执行时间基本是相同的。**但是空间会有占用。**

### 5.8 emplace

https://blog.csdn.net/windpenguin/article/details/75581552

在C++开发过程中，我们经常会用STL的各种容器，比如vector，map，set等，这些容器极大的方便了我们的开发。在使用这些容器的过程中，我们会大量用到的操作就是插入操作，比如vector的push_back，map的insert，set的insert。**这些插入操作会涉及到两次构造，首先是对象的初始化构造，接着在插入的时候会复制一次，会触发拷贝构造。**但是很多时候我们并不需要两次构造带来效率的浪费，如果可以在插入的时候直接构造，就只需要构造一次就够了。

 

C++11标准已经有这样的语法可以直接使用了，那就是emplace。vector有两个函数可以使用：emplace，emplace_back。emplace类似insert，emplace_back类似push_back。通过示例代码可以更清晰的了解到他们的区别。

### 5.9 优先队列——顶堆

https://blog.csdn.net/weixin_36888577/article/details/79937886

定义：`priority_queue<Type, Container, Functional>`

*Type* 就是数据类型，*Container* 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），*Functional* 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆

```c++
auto cmp_working = [&free_time](int a, int b) {
            return free_time[a] > free_time[b];
        };
priority_queue<int, vector<int>, decltype(cmp_working)> q_working_s(cmp_working);
```

这里表示谁的free_time小谁放前面



还有一个debug时要注意，priority_queue只保证top是正确的，其他顺序不一定正确，比如一个大顶堆插入0，1，2应该看到[2,1,0]，但其实可能看到[2,0,1]，然而在你pop之后一定是[1,0]。



### 5.10 decltype

https://www.cnblogs.com/cauchy007/p/4966485.html

　　有时我们希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量（如果要初始化就用auto了）。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

### 5.11 lambda表达式

![image-20201002100609679](F:/日常学习/leetcode.assets/image-20201002100609679.png)

```c++
#include <iostream>
using namespace std;
int main(){
   int n = [] (int x, int y) { return x + y; }(5, 4);
   cout << n << endl;
}
```

> 9

### 5.12 常用内置方法

头文件： #include  <algorithm>

lower_bound(起始地址，结束地址，要查找的数值) 返回的是第一个大于等于待查找数值 出现的位置。

upper_bound(起始地址，结束地址，要查找的数值) 返回的是第一个大于待查找数值 出现的位置。

binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个**bool值**。

