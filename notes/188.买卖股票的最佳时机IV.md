# [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

**提示：**

- `0 <= k <= 109`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

```c++
class Solution {
public:
    int maxProfit(int k, std::vector<int> &prices) {
        if (k==0)return 0;
        std::vector<int> rcd = {};//用来记录递增区间与递减区间的跨度（赚、赔钱数）
        int i = 0, n = prices.size(), rst = 0;
        while (i + 1 < n) {
            int loss = 0;
            while (i + 1 < n && prices[i] >= prices[i + 1]) {
                loss += prices[i] - prices[i + 1];
                i++;
            }
            rcd.push_back(loss);
            int gain = 0;
            while (i + 1 < n && prices[i] <= prices[i + 1]) {
                gain += prices[i + 1] - prices[i];
                i++;
            }
            rcd.push_back(gain);
            rst += gain;
        }
        //这里保证头尾都是递增区间的数值
        if (!rcd.empty())rcd.erase(rcd.begin());
        if (!rcd.empty() && rcd.back() == 0)rcd.erase(rcd.end() - 2, rcd.end());
//        tools::printVectorInt(rcd);
        int count = rcd.size() / 2 + 1;//记录递增区间的个数，如果比k小直接输出rst即可
        while (count > k) {
            int min_loss = rcd.front(), min_id = 0;
            //减少一次交易的最小损失，如果为递增区间表现为不做这个区间的交易，递减区间表现为连接前后两个递增区间。
            for (int j = 0; j < rcd.size(); ++j) {
                if (rcd[j] < min_loss) {
                    min_loss = rcd[j];
                    min_id = j;
                }
            }
            rst -= min_loss;
            if (min_id == 0) {
                rcd.erase(rcd.begin(), rcd.begin() + 2);
            } else if (min_id == rcd.size() - 1) {
                rcd.erase(rcd.end() - 2, rcd.end());
            } else {
                rcd[min_id - 1] += rcd[min_id + 1] - rcd[min_id];
                rcd.erase(rcd.begin() + min_id, rcd.begin() + min_id + 2);
            }
            count--;
//            tools::printVectorInt(rcd);
        }
        return rst;
    }
};
```

> 执行用时：8 ms, 在所有 C++ 提交中击败了89.90% 的用户
>
> 内存消耗：10.8 MB, 在所有 C++ 提交中击败了99.21% 的用户

题解二维动态规划，再说再说吧


