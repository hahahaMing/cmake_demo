# [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

**示例 1:**

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2:**

```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:
 你可以认为每种硬币的数量是无限的。

思路：

贪心放大值硬币，同时记录所有可以正好匹配的情况，更新硬币数最小值

使用递归，当子函数中，整除最大值都比记录的最小值小的时候及时停止，节约时间。

```python
class Solution:
    def coinChange(self, coins: [int], amount: int) -> int:
        if not coins:return -1
        coins.sort()
        print(coins[::-1],amount)
        def recursion(coins: [int], rest: int, nums: [int],least):
            """
            :param num: the sum of num of coins used before
            :return: the sum of num of coins
            """
            trigger = False
            if not coins:
                # print('bad',end='')
                # print(nums)
                return -1
            n = rest // coins[0]
            if sum(nums)+n>least:
                return -1
            if len(coins) == 1:
                if rest % coins[0]:
                    # print('bad', end='')
                    # print(nums)
                    return -1
                else:
                    nums+=[n]
                    print(nums,sum(nums))
                    return sum(nums)
            else:

                next = rest % coins[0]
                for i in range(n + 1):
                    rst = recursion(coins[1:], next + coins[0] * i, nums + [n - i],least)
                    if rst != -1 and rst<least:
                        trigger = True
                        least = rst
            # return least
            if trigger:return least
            return -1
        return recursion(coins[::-1], amount, [],amount//coins[0]+1)
```

> 执行用时 :932 ms, 在所有 Python3 提交中击败了92.39% 的用户
>
> 内存消耗 :13.4 MB, 在所有 Python3 提交中击败了25.16%的用户

牛逼就完了，不看题解先，膨胀。
