# 1190. 反转每对括号间的子串
给出一个字符串 `s`（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 **不应** 包含任何括号。

 

**示例 1：**

**输入：**s = "(abcd)"
**输出：**"dcba"


**示例 2：**

**输入：**s = "(u(love)i)"
**输出：**"iloveu"


**示例 3：**

**输入：**s = "(ed(et(oc))el)"
**输出：**"leetcode"


**示例 4：**

**输入：**s = "a(bcdefghijkl(mno)p)q"
**输出：**"apmnolkjihgfedcbq"




**提示：**


- `0 <= s.length <= 2000`

- `s` 中只有小写英文字母和括号

- 我们确保所有括号都是成对出现的


## 我的代码

```c++
class Solution {
  public:
    string reverseParentheses(string s) {
        stack<stack<char>> stk;
        string rst;
        for (char c : s) {
            if (c == '(') {
                stack<char> tmp;
                stk.push(tmp);
            } else if (c == ')') {
                auto tmp = stk.top();
                stk.pop();
                if (stk.empty()) {
                    while (!tmp.empty()) {
                        rst.push_back(tmp.top());
                        tmp.pop();
                    }
                } else {
                    while (!tmp.empty()) {
                        stk.top().push(tmp.top());
                        tmp.pop();
                    }
                }

            } else {
                if (stk.empty()) {
                    rst.push_back(c);
                } else {
                    stk.top().push(c);
                }
            }
        }
        return rst;
    }
};
```
> 执行用时：4 ms, 在所有 C++ 提交中击败了42.13%的用户
>
> 内存消耗：8.2 MB, 在所有 C++ 提交中击败了5.05%的用户

## 题解

```c++
class Solution {
public:
    string reverseParentheses(string s) {
        stack<string> stk;
        string str;
        for (auto &ch : s) {
            if (ch == '(') {
                stk.push(str);
                str = "";
            } else if (ch == ')') {
                reverse(str.begin(), str.end());
                str = stk.top() + str;
                stk.pop();
            } else {
                str.push_back(ch);
            }
        }
        return str;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/fan-zhuan-mei-dui-gua-hao-jian-de-zi-chu-gwpv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

![fig1](assets/1.png)

第一步我们向右移动到左括号，此时我们跳跃到该左括号对应的右括号（进入了更深一层）；
第二到第三步我们在括号内部向左移动（完成了更深层的遍历）；
第四步我们向左移动到左括号，此时我们跳跃到该左括号对应的右括号（返回到上一层）；
第五步我们在括号外向右移动（继续遍历）。

```c++
class Solution {
public:
    string reverseParentheses(string s) {
        int n = s.length();
        vector<int> pair(n);
        stack<int> stk;
        for (int i = 0; i < n; i++) {
            if (s[i] == '(') {
                stk.push(i);
            } else if (s[i] == ')') {
                int j = stk.top();
                stk.pop();
                pair[i] = j, pair[j] = i;
            }
        }

        string ret;
        int index = 0, step = 1;
        while (index < n) {
            if (s[index] == '(' || s[index] == ')') {
                index = pair[index];
                step = -step;
            } else {
                ret.push_back(s[index]);
            }
            index += step;
        }
        return ret;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/fan-zhuan-mei-dui-gua-hao-jian-de-zi-chu-gwpv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 标签

[0.典型题.md](0.典型题.md)
[1190.反转每对括号间的子串.md](1190.反转每对括号间的子串.md)

栈

预处理括号（特殊）



## 知识点
